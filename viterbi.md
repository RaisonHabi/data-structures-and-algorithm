**维特比算法的基础：**  
- 如果概率最大的路径P（即最短路径）经过某个点，比如图中的x22，那么这条路径从起始点S到x22的这一段子路径Q，一定是S到x22之间的最短路径。否则用S到x22的最短路径R代替Q，便构成了一条比P更短的路径，这显然是矛盾的。
- 从S到E的路径必然经过第i时刻的某个状态，假定第i个时刻有k个状态，那么如果记录了从S到第i个状态的所有k个节点的最短路径,
最终的最短路径必然经过其中的一条。这样，在任意时刻，只要考虑非常有限条最短路径即可。
- 结合上述两点，假定当我们从状态i进入到状态i-1时，从S到状态i上各个节点的最短路径已经找到，并且记录在这些节点上，那么计算从起点S到第i+1状态的某个节点xi+1的最短路径时，只要考虑从S到前一个状态i所有的k个节点的最短路径，以及从这k个节点到xi+1，j的距离即可。

基于上述三点基础，维特比总结了如下的算法。

**维特比算法：**  
- 从点S出发，对于第一个状态xi的各个节点不妨假设有n1个，计算出S待它们之间的距离d（S，x1i），其中X1i代表任意状态1的节点。因为只有一步，所以这些距离都是S扫它们各自的最短距离。
- 对于第二个状态x2的所有节点，要计算出S到它们的最短距离。对于特定节点x2i，从S到它的路径可以经过状态1 的n1中的任何一个节点x1i，对应的路径长度就是d（S，x2i）=d（S，x1j）+d（x1j，x2i）。由于j有n1种可能性，要一一计算，然后找到最小值。  
按照上述方法，从第二个状态走到第三个状态，一直走到最后一个状态，就得到了整个网络从头到尾的最短路径。


